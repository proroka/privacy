import argparse
import matplotlib.pyplot as plt
import numpy as np
import os
import shutil
import subprocess
import tempfile
from xml.dom import minidom
from xml.etree import ElementTree
from xml.etree.ElementTree import Element, SubElement, Comment

import plot_utils


# Name of the StochKit XML file.
_STOCHKIT_FILENAME = 'stochkit.xml'
# Name of folders created by StochKit.
_STOCHKIT_STATS_OUTPUT_MEAN = 'stochkit_output/stats/means.txt'
_STOCHKIT_STATS_OUTPUT_STD = 'stochkit_output/stats/variances.txt'
_STOCHKIT_TRAJECTORIES_OUTPUT = 'stochkit_output/trajectories/trajectory%d.txt'

# Defines a complex.
class Complex(object):
    def __init__(self, species):
        # Build a dictionary of <species, counts>.
        self.counts = {}
        for s in species:
            if s not in self.counts:
                # We define the CRN species as normal strings.
                self.counts[s] = 0
            self.counts[s] += 1

    def __str__(self):
        if self.counts:
            return ' + '.join((('' if c == 1 else str(c)) + s) for s, c in self.counts.iteritems())
        return '(null)'

    def AddXML(self, node, node_type):
        # Type should be either 'Reactants' or 'Products'.
        assert node_type == 'Reactants' or node_type == 'Products'
        subnode = SubElement(node, node_type)
        for s, c in self.counts.iteritems():
            SubElement(subnode, 'SpeciesReference', {'id': s, 'stoichiometry': '%d' % c})
        if not self.counts:
            subnode.append(Comment('no ' + node_type.lower()))


# Defines a reaction.
class Reaction(object):
    def __init__(self, inputs, outputs, rate):
        self.inputs = inputs
        self.outputs = outputs
        self.rate = rate

    def __str__(self):
        return str(self.inputs) + ' -- ' + str(self.outputs)

    def AddXML(self, node, id, ):
        reaction_node = SubElement(node, 'Reaction')
        SubElement(reaction_node, 'Id').text = 'R' + str(id + 1)
        SubElement(reaction_node, 'Description').text = self.__str__()
        SubElement(reaction_node, 'Type').text = 'mass-action'
        SubElement(reaction_node, 'Rate').text = '%g' % self.rate
        self.inputs.AddXML(reaction_node, 'Reactants')
        self.outputs.AddXML(reaction_node, 'Products')


# Defines a CRN.
class CRN(object):
    def __init__(self, stochkit_binary='ssa'):
        self.species = set()  # Set of strings.
        self.species_descriptions = {}  # Species can have a description (defaults to 'Species X').
        self.species_population = {}  # Species have an initial population (defaults to 0).
        self.reactions = []   # List of Reactions.
        self.stochkit_binary = stochkit_binary
        self.ordered_species = []  # Always keep a consistent species order.

    def AddReaction(self, inputs, outputs, rate):
        self.species |= set(inputs)
        self.species |= set(outputs)
        self.ordered_species = sorted(self.species)
        self.reactions.append(Reaction(Complex(inputs), Complex(outputs), rate))

    def SetSpeciesDescription(self, species, description):
        assert species in self.species, 'No reactions with species "%s". Description cannot be set.' % species
        self.species_descriptions[species] = description

    def SetInitialPopulation(self, species, population):
        assert species in self.species, 'No reactions with species "%s". Population cannot be set.' % species
        self.species_population[species] = population

    def __str__(self):
        return '\n'.join(str(r) for r in self.reactions)

    def XMLString(self, description):
        # This function creates a StochKit compatible XML code.
        model_node = Element('Model')
        model_node.append(Comment('Generated by crn.py'))
        SubElement(model_node, 'Description').text = description
        # General info.
        SubElement(model_node, 'NumberOfReactions').text = str(len(self.reactions))
        SubElement(model_node, 'NumberOfSpecies').text = str(len(self.species))
        # Reactions.
        reactionslist_node = SubElement(model_node, 'ReactionsList')
        for i, reaction in enumerate(self.reactions):
            reaction.AddXML(reactionslist_node, i)
        # Species.
        specieslist_node = SubElement(model_node, 'SpeciesList')
        for i, species in enumerate(self.ordered_species):
            species_node = SubElement(specieslist_node, 'Species')
            SubElement(species_node, 'Id').text = species
            SubElement(species_node, 'Description').text = (
                self.species_descriptions[species] if species in self.species_descriptions else
                ('Species %s' % species))
            SubElement(species_node, 'InitialPopulation').text = (
                '%d' % (self.species_population[species] if species in self.species_population else 0))
        # Small trick to make the XML pretty.
        raw_output = ElementTree.tostring(model_node, 'utf-8')
        return minidom.parseString(raw_output).toprettyxml(indent="  ")

    # Runs the complete simulation using StochKit and return 3 values:
    # (a) The list of species
    # (b) The timestamps at which the simulation is snapshot
    # (c) The species population at these timestamps as a 3D tensor with dimensions nruns x ndatapoints x nspecies.
    def Run(self, duration=10.0, nruns=1, ndatapoints=None, output_directory=None):
        # Create XML file (overwrite old file if any).
        # If output_directory is None, create a temporary directory.
        cleandir = False
        if output_directory is None:
            output_directory = tempfile.mkdtemp()
            cleandir = True
        xmlpath = os.path.join(output_directory, _STOCHKIT_FILENAME)
        with open(xmlpath, 'w') as fp:
            fp.write(self.XMLString('Autogenerated CRN'))
        # Keep one datapoint per time unit if ndatapoints is not set.
        if ndatapoints is None:
            ndatapoints = int(duration) + 1
        # Prepare command.
        commandline = [
            self.stochkit_binary,
            '-m', xmlpath,
            '-t', '%g' % duration,
            '-r', '%d' % nruns,
            '-i', '%d' % (ndatapoints - 1),
            '--keep-trajectories',
            '-f']
        print 'Executing:', ' '.join(commandline)
        subprocess.call(commandline)
        # Gather trajectories back into numpy arrays.
        timestamps = np.empty((ndatapoints, 1))
        data = np.empty((nruns, ndatapoints, len(self.species)))
        for run in xrange(nruns):
            run_filename = os.path.join(output_directory, _STOCHKIT_TRAJECTORIES_OUTPUT % run)
            d = np.loadtxt(run_filename)
            data[run, :, :] = d[:, 1:]
            if run == 0:
                timestamps = d[:, 0]
        if cleandir:
            shutil.rmtree(output_directory)
        return self.ordered_species, timestamps, data


if __name__ == '__main__':
    # Parsing arguments to get the path to the StochKit binary.
    parser = argparse.ArgumentParser(description='Runs StochKit on a test CRN.')
    parser.add_argument('--stochkit_path', metavar='PATH', action='store', default='./StochKit2.0.11/ssa', help='Path where the stochkit binary is stored')
    args = parser.parse_args()
    # Testing.
    crn = CRN(stochkit_binary=args.stochkit_path)
    crn.AddReaction(['A', 'B'], ['C'], 1.)  # A + B -> C
    crn.AddReaction(['C'] * 2, ['D'], 0.5)  # 2C -> D
    crn.AddReaction(['D'], [], 2.)          # D -> (nothing)
    crn.AddReaction([], ['A', 'B'], 1.)     # (nothing) -> A + B
    crn.SetInitialPopulation('A', 10)
    print 'Running simulation on:'
    print crn, '\n'
    # Run simulation.
    output = crn.Run(duration=20., nruns=100)
    # Plot average.
    plotter = plot_utils.Plotter(output)
    plotter.AverageTrajectory()
    # Plot distribution of the species populations after 10 seconds.
    plotter.Distributions(from_timestamp=10.)
    plt.show()
